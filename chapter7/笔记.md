# 数据存储全方案，详解持久化技术



任何一个应用程序，其实说白了就是在不停地和数据打交道，我们聊QQ、看新闻、刷微博，所关心的都是里面的数据，没有数据的应用程序就变成了一个空壳子，对用户来说没有任何实际用途。那么这些数据是从哪儿来的呢？现在多数的数据基本是由用户产生的，比如你发微博、评论新闻，其实都是在产生数据。



前面章节所编写的众多例子中也使用到了一些数据，例如第4章最佳实践部分在聊天界面编写的聊天内容，第6章最佳实践部分在登录界面输入的账号和密码。这些数据有一个共同点，即它们都属于瞬时数据。那么什么是瞬时数据呢？就是指那些存储在内存当中，有可能会因为程序关闭或其他原因导致内存被回收而丢失的数据。这对于一些关键性的数据信息来说是绝对不能容忍的，谁都不希望自己刚发出去的一条微博，刷新一下就没了吧。那么怎样才能保证一些关键性的数据不会丢失呢？这就需要用到数据持久化技术了。



## 持久化技术简介

数据持久化就是指将那些内存中的瞬时数据保存到存储设备中，保证即使在手机或计算机关机的情况下，这些数据仍然不会丢失。保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据是处于持久状态的。持久化技术提供了一种机制，可以让数据在瞬时状态和持久状态之间进行转换。



持久化技术被广泛应用于各种程序设计领域，而本节要探讨的自然是Android中的数据持久化技术。Android系统中主要提供了3种方式用于简单地实现数据持久化功能：文件存储、SharedPreferences存储以及数据库存储。



## 文件存储

文件存储是Android中最基本的数据存储方式，它不对存储的内容进行任何格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合存储一些简单的文本数据或二进制数据。如果想使用文件存储的方式来保存一些较为复杂的结构化数据，就需要定义一套自己的格式规范，方便之后将数据从文件中重新解析出来。



### 将数据存储到文件中

Context类中提供了一个openFileOutput()方法，可以用于将数据存储到指定的文件中。这个方法接收两个参数：第一个参数是文件名，在文件创建的时候使用，注意这里指定的文件名不可以包含路径，因为所有的文件都默认存储到`/data/data/<package name>/files/`目录下；第二个参数是文件的操作模式，主要有MODE_PRIVATE和MODE_APPEND两种模式可选，默认是MODE_PRIVATE，表示当指定相同文件名的时候，所写入的内容将会覆盖原文件中的内容，而MODE_APPEND则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。其实文件的操作模式本来还有另外两种：MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE。这两种模式表示允许其他应用程序对我们程序中的文件进行读写操作，不过由于这两种模式过于危险，很容易引起应用的安全漏洞，已在Android 4.2版本中被废弃。



openFileOutput()方法返回的是一个FileOutputStream对象，得到这个对象之后就可以使用Java流的方式将数据写入文件中了。以下是一段简单的代码示例，展示了如何将一段文本内容保存到文件中：

```kotlin
fun save(inputText: String) {
    try {
        val output = openFileOutput("data", Context.MODE_PRIVATE)
        val writer = BufferedWriter(OutputStreamWriter(output))
        writer.use {
        	it.write(inputText)
        }
    } catch (e: IOException) {
    	e.printStackTrace()
    }
}
```

这里通过openFileOutput()方法能够得到一个FileOutputStream对象，然后借助它构建出一个OutputStreamWriter对象，接着再使用OutputStreamWriter构建出一个BufferedWriter对象，这样就可以通过BufferedWriter将文本内容写入文件中了。



注意，这里还使用了一个use函数，这是Kotlin提供的一个内置扩展函数。它会保证在Lambda表达式中的代码全部执行完之后自动将外层的流关闭，这样就不需要我们再编写一个finally语句，手动去关闭流了，是一个非常好用的扩展函数。



另外，Kotlin是没有异常检查机制（checked exception）的。这意味着使用Kotlin编写的所有代码都不会强制要求你进行异常捕获或异常抛出。上述代码中的try catch代码块是参照Java的编程规范添加的，即使你不写try catch代码块，在Kotlin中依然可以编译通过。



下面编写一个完整的例子，借此学习一下如何在Android项目中使用文件存储的技术。首先创建一个FilePersistenceTest项目，并修改activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <EditText
        android:id="@+id/editText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Type something here"
        />
</LinearLayout>
```

这里只是在布局中加入了一个EditText，用于输入文本内容。



可以运行一下程序了，界面上肯定会有一个文本输入框。然后在文本输入框中随意输入点什么内容，再按下Back键，这时输入的内容肯定就已经丢失了，因为它只是瞬时数据，在Activity被销毁后就会被回收。而这里我们要做的，就是在数据被回收之前，将它存储到文件当中。修改MainActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.os.Bundle
import android.widget.EditText
import androidx.appcompat.app.AppCompatActivity
import java.io.BufferedWriter
import java.io.IOException
import java.io.OutputStreamWriter

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    /**
     * 重写onDestroy方法，保证在Activity销毁之前一定会调用到这个方法
     *
     * 销毁前获取editText中的内容并保存到文件中
     */
    override fun onDestroy() {
        super.onDestroy()
        val editText : EditText = findViewById(R.id.editText)
        val inputText = editText.text.toString()
        save(inputText)
    }

    /**
     * 将输入框中的文本保存到文件中
     */
    private fun save(inputText:String){
        try {
            val output = openFileOutput("data",Context.MODE_PRIVATE)
            val writer = BufferedWriter(OutputStreamWriter(output))
            writer.use {
                it.write(inputText)
            }
        }catch (e: IOException){
            e.printStackTrace()
        }
    }
}
```

现在重新运行一下程序，并在EditText中输入一些内容。然后按下Back键关闭程序，这时我们输入的内容就保存到文件中了。那么如何才能证实数据确
实已经保存成功了呢？我们可以借助Device File Explorer工具查看一下。这个工具在AndroidStudio的右侧边栏当中，通常是在右下角的位置，如果你的右侧边栏中没有这个工具的话，也可以使用快捷键Ctrl + Shift + A（Mac系统是command + shift + A）打开搜索功能，在搜索框中输入“Device File Explorer”即可找到这个工具。



这个工具其实就相当于一个设备文件浏览器，在这里找到/data/data/io.github.pvnk1u/files/目录，可以看到，现在已经生成了一个data文件，双击这个文件就可以查看里面的内容。这样就证实了在EditText中输入的内容确实已经成功保存到文件中了。



不过，只是成功将数据保存下来还不够，还需要想办法在下次启动程序的时候让这些数据能够还原到EditText中，因此接下来就要学习一下如何从文件中读取数据。



### 从文件中读取数据

类似于将数据存储到文件中，Context类中还提供了一个openFileInput()方法，用于从文件中读取数据。这个方法要比openFileOutput()简单一些，它只接收一个参数，即要读取的文件名，然后系统会自动到`/data/data/<package name>/files/`目录下加载这个文件，并返回一个FileInputStream对象，得到这个对象之后，再通过流的方式就可以将数据读取出来了。



以下是一段简单的代码示例，展示了如何从文件中读取文本数据：

```kotlin
fun load(): String {
	val content = StringBuilder()
	try {
        val input = openFileInput("data")
        val reader = BufferedReader(InputStreamReader(input))
        reader.use {
            reader.forEachLine {
                content.append(it)
            }
        }
    } catch (e: IOException) {
    	e.printStackTrace()
    }
    return content.toString()
}
```

在这段代码中，首先通过openFileInput()方法获取了一个FileInputStream对象，然后借助它又构建出了一个InputStreamReader对象，接着再使用InputStreamReader构建出一个BufferedReader对象，这样就可以通过BufferedReader将文件中的数据一行行读取出来，并拼接到StringBuilder对象当中，最后将读取的内容返回就可以了。



注意，这里从文件中读取数据使用了一个forEachLine函数，这也是Kotlin提供的一个内置扩展函数，它会将读到的每行内容都回调到Lambda表达式中，我们在Lambda表达式中完成拼接逻辑即可。



了解了从文件中读取数据的方法，就来继续完善上一小节中的例子，使得重新启动程序时EditText中能够保留我们上次输入的内容。修改MainActivity中的代码，如下所示：

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 应用重启后重新加载onDestroy时保存的内容
         * */
        val editText : EditText = findViewById(R.id.editText)
        val inputText = load()
        if (inputText.isNotEmpty()){
            editText.setText(inputText)
            // 调用setSelection()方法将输入光标移动到文本的末尾位置以便继续输入
            editText.setSelection(inputText.length)
            Toast.makeText(this,"Restoring succeeded",Toast.LENGTH_SHORT).show()
        }
    }

    /**
     * 从文件中读取数据
     */
    private fun load(): String {
        val content = StringBuilder()
        try {
            // 将会读取/data/data/<package name>/files/data 文件中的内容
            val input = openFileInput("data")
            val reader = BufferedReader(InputStreamReader(input))
            reader.use {
                reader.forEachLine {
                    content.append(it)
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return content.toString()
    }


}
```



可以看到，这里的思路非常简单，在onCreate()方法中调用load()方法读取文件中存储的文本内容，如果读到的内容不为空，就调用EditText的setText()方法将内容填充到EditText里，并调用setSelection()方法将输入光标移动到文本的末尾位置以便继续输入，然后弹出一句还原成功的提示。load()方法中的细节我们在前面已经讲过，这里就不再赘述了。



这样我们就已经把文件存储方面的知识学习完了，其实所用到的核心技术就是Context类中提供的openFileInput()和openFileOutput()方法，之后就是利用各种流来进行读写操作。



不过，正如前面所说，文件存储的方式并不适合用于保存一些较为复杂的结构型数据，因此，下面我们就来学习一下Android中另一种数据持久化的方式，它比文件存储更加简单易用，而且可以很方便地对某些指定的数据进行读写操作。



## SharedPreferences存储

不同于文件的存储方式，SharedPreferences是使用键值对的方式来存储数据的。也就是说，当保存一条数据的时候，需要给这条数据提供一个对应的键，这样在读取数据的时候就可以通过这个键把相应的值取出来。而且SharedPreferences还支持多种不同的数据类型存储，如果存储的数据类型是整型，那么读取出来的数据也是整型的；如果存储的数据是一个字符串，那么读取出来的数据仍然是字符串。



### 将数据存储到SharedPreferences中

要想使用SharedPreferences存储数据，首先需要获取SharedPreferences对象。Android中主要提供了以下两种方法用于得到SharedPreferences对象。



1. Context类中的getSharedPreferences()方法

   此方法接收两个参数：第一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences文件都是存放在`/data/data/<package name>/shared_prefs/`目录下的；第二个参数用于指定操作模式，目前只有默认的MODE_PRIVATE这一种模式可选，它和直接传入0的效果是相同的，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。其他几种操作模式均已被废弃，MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE这两种模式是在Android 4.2版本中被废弃的，MODE_MULTI_PROCESS模式是在Android 6.0版本中被废弃的。

2. Activity类中的getPreferences()方法

   这个方法和Context中的getSharedPreferences()方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreferences的文件名。

   

   得到了SharedPreferences对象之后，就可以开始向SharedPreferences文件中存储数据了，主要可以分为3步实现。

   - 调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。
   - 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。
   - 调用apply()方法将添加的数据提交，从而完成数据存储操作。



新建一个SharedPreferencesTest项目，然后修改activity_main.xml中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <!--保存数据的按钮-->
    <Button
        android:id="@+id/saveButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save Data"
        />
</LinearLayout>
```

这里不做任何复杂的功能，只是简单地放置了一个按钮，用于将一些数据存储到SharedPreferences文件当中。然后修改MainActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.os.Bundle
import android.widget.Button
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 设置保存按钮的点击事件
         * */
        val saveButton:Button = findViewById(R.id.saveButton)
        saveButton.setOnClickListener{
            /**
             * 通过getSharedPreferences()方法指定SharedPreferences的文件名为data，并得到了
             * SharedPreferences.Editor对象。接着向这个对象中添加了3条不同类型的数据，最
             * 后调用apply()方法进行提交，从而完成了数据存储的操作。
             */
            val editor = getSharedPreferences("data",Context.MODE_PRIVATE).edit()
            editor.putString("name","Tom")
            editor.putInt("age",28)
            editor.putBoolean("married",false)
            editor.apply()
        }
    }
}
```

现在就可以运行一下程序了。进入程序的主界面后，点击一下“Save Data”按钮。这时的数据应该已经保存成功了，不过为了证实一下，还是要借助Device FileExplorer来进行查看。打开Device File Explorer，然后进入/data/data/io.github.pvnk1u/shared_prefs/目录下，可以看到生成了一个data.xml文件。



那么接下来要看一看，如何从SharedPreferences文件中去读取这些存储的数据了。



### 从SharedPreferences中读取数据

使用SharedPreferences存储数据是非常简单的，不过下面还有更好的消息，因为从SharedPreferences文件中读取数据会更加简单。SharedPreferences对象中提供了一系列的get方法，用于读取存储的数据，每种get方法都对应了SharedPreferences.Editor中的一种put方法，比如读取一个布尔型数据就使用getBoolean()方法，读取一个字符串就使用getString()方法。这些get方法都接收两个参数：第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回。



还是通过例子来实际体验一下吧，仍然是在SharedPreferencesTest项目的基础上继续开发，修改activity_main.xml中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <!--保存数据的按钮-->
    <Button
        android:id="@+id/saveButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save Data"
        />

    <!--还原数据的按钮-->
    <Button
        android:id="@+id/restoreButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Restore Data"
        />
</LinearLayout>
```

这里增加了一个还原数据的按钮，我们希望通过点击这个按钮来从SharedPreferences文件中读取数据。修改MainActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.os.Bundle
import android.util.Log
import android.widget.Button
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 设置保存按钮的点击事件
         * */
        val saveButton:Button = findViewById(R.id.saveButton)
        saveButton.setOnClickListener{
            /**
             * 通过getSharedPreferences()方法指定SharedPreferences的文件名为data，并得到了
             * SharedPreferences.Editor对象。接着向这个对象中添加了3条不同类型的数据，最
             * 后调用apply()方法进行提交，从而完成了数据存储的操作。
             */
            val editor = getSharedPreferences("data",Context.MODE_PRIVATE).edit()
            editor.putString("name","Tom")
            editor.putInt("age",28)
            editor.putBoolean("married",false)
            editor.apply()
        }


        /**
         * 设置还原数据按钮的点击事件
         */
        val restoreButton : Button = findViewById(R.id.restoreButton)
        restoreButton.setOnClickListener {
            /**
             * 在还原数据按钮的点击事件中首先通过getSharedPreferences()方法得到
             * 了SharedPreferences对象，然后分别调用它的getString()、getInt()和
             * getBoolean()方法，去获取前面所存储的姓名、年龄和是否已婚，如果没有找到相应的值，
             * 就会使用方法中传入的默认值来代替，最后通过Log将这些值打印出来。
             */
            val prefs = getSharedPreferences("data", Context.MODE_PRIVATE)
            val name = prefs.getString("name", "")
            val age = prefs.getInt("age", 0)
            val married = prefs.getBoolean("married", false)
            Log.d("MainActivity", "name is $name")
            Log.d("MainActivity", "age is $age")
            Log.d("MainActivity", "married is $married")
        }
    }
}
```

重启程序，并点击界面上的“Restore data”按钮，可以看到Logcat中已经打印了之前存储的数据。通过这个例子，我们就把SharedPreferences存储的
知识学习完了。相比之下，SharedPreferences存储确实要比文本存储简单方便了许多，应用场景也多了不少，比如很多应用程序中的偏好设置功能其实就使用到了SharedPreferences技术。





### 实现记住密码功能

新建RememberPassword项目，创建activity_login.xml并修改代码：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Account:" />

        <EditText
            android:id="@+id/accountEdit"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical" />
    </LinearLayout>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Password:" />

        <EditText
            android:id="@+id/passwordEdit"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical"
            android:inputType="textPassword" />
    </LinearLayout>

    <!--这里使用了一个新控件：CheckBox。这是一个复选框控件，用户可以通过点击的方式进行选中
        和取消，我们就使用这个控件来表示用户是否需要记住密码。-->
    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <CheckBox
            android:id="@+id/rememberPass"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="18sp"
            android:text="Remember password" />
    </LinearLayout>

    <Button
        android:id="@+id/login"
        android:layout_width="200dp"
        android:layout_height="60dp"
        android:layout_gravity="center_horizontal"
        android:text="Login" />

</LinearLayout>
```

这里使用了一个新控件：CheckBox。这是一个复选框控件，用户可以通过点击的方式进行选中和取消，我们就使用这个控件来表示用户是否需要记住密码。



然后修改LoginActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.widget.Button
import android.widget.CheckBox
import android.widget.EditText
import android.widget.Toast

class LoginActivity : BaseActivity(){

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)
        // 获取了SharedPreferences对象，然后调用它的getBoolean()方法去获取remember_password这个键对应的值。
        val prefs = getPreferences(Context.MODE_PRIVATE)
        val isRemember = prefs.getBoolean("remember_password", false)
        val accountEdit : EditText = findViewById(R.id.accountEdit)
        val passwordEdit : EditText = findViewById(R.id.passwordEdit)
        val rememberPass : CheckBox = findViewById(R.id.rememberPass)
        val login : Button = findViewById(R.id.login)
        // 如果设置了记住密码，将用户名密码设置到对应的文本框中,第一次登陆时肯定是false
        if (isRemember) {
            // 将账号和密码都设置到文本框中
            val account = prefs.getString("account", "")
            val password = prefs.getString("password", "")
            accountEdit.setText(account)
            passwordEdit.setText(password)
            rememberPass.isChecked = true
        }
        login.setOnClickListener {
            val account = accountEdit.text.toString()
            val password = passwordEdit.text.toString()
            // 如果账号是admin且密码是123456，就认为登录成功
            if (account == "admin" && password == "123456") {
                /**
                 * 在登录成功之后，会调用CheckBox的isChecked()方法来检查复选框是否被选中。如果被选中了，则表示用户想要记
                 * 住密码，这时将remember_password设置为true，然后把account和password对应的值都
                 * 存入SharedPreferences文件中并提交；如果没有被选中，就简单地调用一下clear()方法，
                 * 将SharedPreferences文件中的数据全部清除掉。
                 */
                val editor = prefs.edit()
                if (rememberPass.isChecked) { // 检查复选框是否被选中
                    editor.putBoolean("remember_password", true)
                    editor.putString("account", account)
                    editor.putString("password", password)
                } else {
                    editor.clear()
                }
                editor.apply()
                val intent = Intent(this, MainActivity::class.java)
                startActivity(intent)
                finish()
            } else {
                Toast.makeText(this, "account or password is invalid",
                    Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

可以看到，这里首先在onCreate()方法中获取了SharedPreferences对象，然后调用它的getBoolean()方法去获取remember_password这个键对应的值。一开始当然不存在对应的值了，所以会使用默认值false，这样就什么都不会发生。接着在登录成功之后，会调用CheckBox的isChecked()方法来检查复选框是否被选中。如果被选中了，则表示用户想要记住密码，这时将remember_password设置为true，然后把account和password对应的值都存入SharedPreferences文件中并提交；如果没有被选中，就简单地调用一下clear()方法，将SharedPreferences文件中的数据全部清除掉。



当用户选中了记住密码复选框，并成功登录一次之后，remember_password键对应的值就是true了，这个时候如果重新启动登录界面，就会从SharedPreferences文件中将保存的账号和密码都读取出来，并填充到文本输入框中，然后把记住密码复选框选中，这样就完成记住密码的功能了。



现在重新运行一下程序，可以看到界面上多了一个记住密码复选框，然后账号输入admin，密码输入123456，并选中记住密码复选框，点击登录，就会跳转到
MainActivity。接着在MainActivity中发出一条强制下线广播，会让程序重新回到登录界面，此时会发现，账号和密码已经自动填充到界面上了。



