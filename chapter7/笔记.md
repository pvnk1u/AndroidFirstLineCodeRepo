# 数据存储全方案，详解持久化技术



任何一个应用程序，其实说白了就是在不停地和数据打交道，我们聊QQ、看新闻、刷微博，所关心的都是里面的数据，没有数据的应用程序就变成了一个空壳子，对用户来说没有任何实际用途。那么这些数据是从哪儿来的呢？现在多数的数据基本是由用户产生的，比如你发微博、评论新闻，其实都是在产生数据。



前面章节所编写的众多例子中也使用到了一些数据，例如第4章最佳实践部分在聊天界面编写的聊天内容，第6章最佳实践部分在登录界面输入的账号和密码。这些数据有一个共同点，即它们都属于瞬时数据。那么什么是瞬时数据呢？就是指那些存储在内存当中，有可能会因为程序关闭或其他原因导致内存被回收而丢失的数据。这对于一些关键性的数据信息来说是绝对不能容忍的，谁都不希望自己刚发出去的一条微博，刷新一下就没了吧。那么怎样才能保证一些关键性的数据不会丢失呢？这就需要用到数据持久化技术了。



## 持久化技术简介

数据持久化就是指将那些内存中的瞬时数据保存到存储设备中，保证即使在手机或计算机关机的情况下，这些数据仍然不会丢失。保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据是处于持久状态的。持久化技术提供了一种机制，可以让数据在瞬时状态和持久状态之间进行转换。



持久化技术被广泛应用于各种程序设计领域，而本节要探讨的自然是Android中的数据持久化技术。Android系统中主要提供了3种方式用于简单地实现数据持久化功能：文件存储、SharedPreferences存储以及数据库存储。



## 文件存储

文件存储是Android中最基本的数据存储方式，它不对存储的内容进行任何格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合存储一些简单的文本数据或二进制数据。如果想使用文件存储的方式来保存一些较为复杂的结构化数据，就需要定义一套自己的格式规范，方便之后将数据从文件中重新解析出来。



### 将数据存储到文件中

Context类中提供了一个openFileOutput()方法，可以用于将数据存储到指定的文件中。这个方法接收两个参数：第一个参数是文件名，在文件创建的时候使用，注意这里指定的文件名不可以包含路径，因为所有的文件都默认存储到`/data/data/<package name>/files/`目录下；第二个参数是文件的操作模式，主要有MODE_PRIVATE和MODE_APPEND两种模式可选，默认是MODE_PRIVATE，表示当指定相同文件名的时候，所写入的内容将会覆盖原文件中的内容，而MODE_APPEND则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。其实文件的操作模式本来还有另外两种：MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE。这两种模式表示允许其他应用程序对我们程序中的文件进行读写操作，不过由于这两种模式过于危险，很容易引起应用的安全漏洞，已在Android 4.2版本中被废弃。



openFileOutput()方法返回的是一个FileOutputStream对象，得到这个对象之后就可以使用Java流的方式将数据写入文件中了。以下是一段简单的代码示例，展示了如何将一段文本内容保存到文件中：

```kotlin
fun save(inputText: String) {
    try {
        val output = openFileOutput("data", Context.MODE_PRIVATE)
        val writer = BufferedWriter(OutputStreamWriter(output))
        writer.use {
        	it.write(inputText)
        }
    } catch (e: IOException) {
    	e.printStackTrace()
    }
}
```

这里通过openFileOutput()方法能够得到一个FileOutputStream对象，然后借助它构建出一个OutputStreamWriter对象，接着再使用OutputStreamWriter构建出一个BufferedWriter对象，这样就可以通过BufferedWriter将文本内容写入文件中了。



注意，这里还使用了一个use函数，这是Kotlin提供的一个内置扩展函数。它会保证在Lambda表达式中的代码全部执行完之后自动将外层的流关闭，这样就不需要我们再编写一个finally语句，手动去关闭流了，是一个非常好用的扩展函数。



另外，Kotlin是没有异常检查机制（checked exception）的。这意味着使用Kotlin编写的所有代码都不会强制要求你进行异常捕获或异常抛出。上述代码中的try catch代码块是参照Java的编程规范添加的，即使你不写try catch代码块，在Kotlin中依然可以编译通过。



下面编写一个完整的例子，借此学习一下如何在Android项目中使用文件存储的技术。首先创建一个FilePersistenceTest项目，并修改activity_main.xml中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <EditText
        android:id="@+id/editText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Type something here"
        />
</LinearLayout>
```

这里只是在布局中加入了一个EditText，用于输入文本内容。



可以运行一下程序了，界面上肯定会有一个文本输入框。然后在文本输入框中随意输入点什么内容，再按下Back键，这时输入的内容肯定就已经丢失了，因为它只是瞬时数据，在Activity被销毁后就会被回收。而这里我们要做的，就是在数据被回收之前，将它存储到文件当中。修改MainActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.os.Bundle
import android.widget.EditText
import androidx.appcompat.app.AppCompatActivity
import java.io.BufferedWriter
import java.io.IOException
import java.io.OutputStreamWriter

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    /**
     * 重写onDestroy方法，保证在Activity销毁之前一定会调用到这个方法
     *
     * 销毁前获取editText中的内容并保存到文件中
     */
    override fun onDestroy() {
        super.onDestroy()
        val editText : EditText = findViewById(R.id.editText)
        val inputText = editText.text.toString()
        save(inputText)
    }

    /**
     * 将输入框中的文本保存到文件中
     */
    private fun save(inputText:String){
        try {
            val output = openFileOutput("data",Context.MODE_PRIVATE)
            val writer = BufferedWriter(OutputStreamWriter(output))
            writer.use {
                it.write(inputText)
            }
        }catch (e: IOException){
            e.printStackTrace()
        }
    }
}
```

现在重新运行一下程序，并在EditText中输入一些内容。然后按下Back键关闭程序，这时我们输入的内容就保存到文件中了。那么如何才能证实数据确
实已经保存成功了呢？我们可以借助Device File Explorer工具查看一下。这个工具在AndroidStudio的右侧边栏当中，通常是在右下角的位置，如果你的右侧边栏中没有这个工具的话，也可以使用快捷键Ctrl + Shift + A（Mac系统是command + shift + A）打开搜索功能，在搜索框中输入“Device File Explorer”即可找到这个工具。



这个工具其实就相当于一个设备文件浏览器，在这里找到/data/data/io.github.pvnk1u/files/目录，可以看到，现在已经生成了一个data文件，双击这个文件就可以查看里面的内容。这样就证实了在EditText中输入的内容确实已经成功保存到文件中了。



不过，只是成功将数据保存下来还不够，还需要想办法在下次启动程序的时候让这些数据能够还原到EditText中，因此接下来就要学习一下如何从文件中读取数据。



### 从文件中读取数据

类似于将数据存储到文件中，Context类中还提供了一个openFileInput()方法，用于从文件中读取数据。这个方法要比openFileOutput()简单一些，它只接收一个参数，即要读取的文件名，然后系统会自动到`/data/data/<package name>/files/`目录下加载这个文件，并返回一个FileInputStream对象，得到这个对象之后，再通过流的方式就可以将数据读取出来了。



以下是一段简单的代码示例，展示了如何从文件中读取文本数据：

```kotlin
fun load(): String {
	val content = StringBuilder()
	try {
        val input = openFileInput("data")
        val reader = BufferedReader(InputStreamReader(input))
        reader.use {
            reader.forEachLine {
                content.append(it)
            }
        }
    } catch (e: IOException) {
    	e.printStackTrace()
    }
    return content.toString()
}
```

在这段代码中，首先通过openFileInput()方法获取了一个FileInputStream对象，然后借助它又构建出了一个InputStreamReader对象，接着再使用InputStreamReader构建出一个BufferedReader对象，这样就可以通过BufferedReader将文件中的数据一行行读取出来，并拼接到StringBuilder对象当中，最后将读取的内容返回就可以了。



注意，这里从文件中读取数据使用了一个forEachLine函数，这也是Kotlin提供的一个内置扩展函数，它会将读到的每行内容都回调到Lambda表达式中，我们在Lambda表达式中完成拼接逻辑即可。



了解了从文件中读取数据的方法，就来继续完善上一小节中的例子，使得重新启动程序时EditText中能够保留我们上次输入的内容。修改MainActivity中的代码，如下所示：

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 应用重启后重新加载onDestroy时保存的内容
         * */
        val editText : EditText = findViewById(R.id.editText)
        val inputText = load()
        if (inputText.isNotEmpty()){
            editText.setText(inputText)
            // 调用setSelection()方法将输入光标移动到文本的末尾位置以便继续输入
            editText.setSelection(inputText.length)
            Toast.makeText(this,"Restoring succeeded",Toast.LENGTH_SHORT).show()
        }
    }

    /**
     * 从文件中读取数据
     */
    private fun load(): String {
        val content = StringBuilder()
        try {
            // 将会读取/data/data/<package name>/files/data 文件中的内容
            val input = openFileInput("data")
            val reader = BufferedReader(InputStreamReader(input))
            reader.use {
                reader.forEachLine {
                    content.append(it)
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return content.toString()
    }


}
```



可以看到，这里的思路非常简单，在onCreate()方法中调用load()方法读取文件中存储的文本内容，如果读到的内容不为空，就调用EditText的setText()方法将内容填充到EditText里，并调用setSelection()方法将输入光标移动到文本的末尾位置以便继续输入，然后弹出一句还原成功的提示。load()方法中的细节我们在前面已经讲过，这里就不再赘述了。



这样我们就已经把文件存储方面的知识学习完了，其实所用到的核心技术就是Context类中提供的openFileInput()和openFileOutput()方法，之后就是利用各种流来进行读写操作。



不过，正如前面所说，文件存储的方式并不适合用于保存一些较为复杂的结构型数据，因此，下面我们就来学习一下Android中另一种数据持久化的方式，它比文件存储更加简单易用，而且可以很方便地对某些指定的数据进行读写操作。



## SharedPreferences存储

不同于文件的存储方式，SharedPreferences是使用键值对的方式来存储数据的。也就是说，当保存一条数据的时候，需要给这条数据提供一个对应的键，这样在读取数据的时候就可以通过这个键把相应的值取出来。而且SharedPreferences还支持多种不同的数据类型存储，如果存储的数据类型是整型，那么读取出来的数据也是整型的；如果存储的数据是一个字符串，那么读取出来的数据仍然是字符串。



### 将数据存储到SharedPreferences中

要想使用SharedPreferences存储数据，首先需要获取SharedPreferences对象。Android中主要提供了以下两种方法用于得到SharedPreferences对象。



1. Context类中的getSharedPreferences()方法

   此方法接收两个参数：第一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences文件都是存放在`/data/data/<package name>/shared_prefs/`目录下的；第二个参数用于指定操作模式，目前只有默认的MODE_PRIVATE这一种模式可选，它和直接传入0的效果是相同的，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。其他几种操作模式均已被废弃，MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE这两种模式是在Android 4.2版本中被废弃的，MODE_MULTI_PROCESS模式是在Android 6.0版本中被废弃的。

2. Activity类中的getPreferences()方法

   这个方法和Context中的getSharedPreferences()方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreferences的文件名。

   

   得到了SharedPreferences对象之后，就可以开始向SharedPreferences文件中存储数据了，主要可以分为3步实现。

   - 调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。
   - 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。
   - 调用apply()方法将添加的数据提交，从而完成数据存储操作。



新建一个SharedPreferencesTest项目，然后修改activity_main.xml中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <!--保存数据的按钮-->
    <Button
        android:id="@+id/saveButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save Data"
        />
</LinearLayout>
```

这里不做任何复杂的功能，只是简单地放置了一个按钮，用于将一些数据存储到SharedPreferences文件当中。然后修改MainActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.os.Bundle
import android.widget.Button
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 设置保存按钮的点击事件
         * */
        val saveButton:Button = findViewById(R.id.saveButton)
        saveButton.setOnClickListener{
            /**
             * 通过getSharedPreferences()方法指定SharedPreferences的文件名为data，并得到了
             * SharedPreferences.Editor对象。接着向这个对象中添加了3条不同类型的数据，最
             * 后调用apply()方法进行提交，从而完成了数据存储的操作。
             */
            val editor = getSharedPreferences("data",Context.MODE_PRIVATE).edit()
            editor.putString("name","Tom")
            editor.putInt("age",28)
            editor.putBoolean("married",false)
            editor.apply()
        }
    }
}
```

现在就可以运行一下程序了。进入程序的主界面后，点击一下“Save Data”按钮。这时的数据应该已经保存成功了，不过为了证实一下，还是要借助Device FileExplorer来进行查看。打开Device File Explorer，然后进入/data/data/io.github.pvnk1u/shared_prefs/目录下，可以看到生成了一个data.xml文件。



那么接下来要看一看，如何从SharedPreferences文件中去读取这些存储的数据了。



### 从SharedPreferences中读取数据

使用SharedPreferences存储数据是非常简单的，不过下面还有更好的消息，因为从SharedPreferences文件中读取数据会更加简单。SharedPreferences对象中提供了一系列的get方法，用于读取存储的数据，每种get方法都对应了SharedPreferences.Editor中的一种put方法，比如读取一个布尔型数据就使用getBoolean()方法，读取一个字符串就使用getString()方法。这些get方法都接收两个参数：第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回。



还是通过例子来实际体验一下吧，仍然是在SharedPreferencesTest项目的基础上继续开发，修改activity_main.xml中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <!--保存数据的按钮-->
    <Button
        android:id="@+id/saveButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save Data"
        />

    <!--还原数据的按钮-->
    <Button
        android:id="@+id/restoreButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Restore Data"
        />
</LinearLayout>
```

这里增加了一个还原数据的按钮，我们希望通过点击这个按钮来从SharedPreferences文件中读取数据。修改MainActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.os.Bundle
import android.util.Log
import android.widget.Button
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 设置保存按钮的点击事件
         * */
        val saveButton:Button = findViewById(R.id.saveButton)
        saveButton.setOnClickListener{
            /**
             * 通过getSharedPreferences()方法指定SharedPreferences的文件名为data，并得到了
             * SharedPreferences.Editor对象。接着向这个对象中添加了3条不同类型的数据，最
             * 后调用apply()方法进行提交，从而完成了数据存储的操作。
             */
            val editor = getSharedPreferences("data",Context.MODE_PRIVATE).edit()
            editor.putString("name","Tom")
            editor.putInt("age",28)
            editor.putBoolean("married",false)
            editor.apply()
        }


        /**
         * 设置还原数据按钮的点击事件
         */
        val restoreButton : Button = findViewById(R.id.restoreButton)
        restoreButton.setOnClickListener {
            /**
             * 在还原数据按钮的点击事件中首先通过getSharedPreferences()方法得到
             * 了SharedPreferences对象，然后分别调用它的getString()、getInt()和
             * getBoolean()方法，去获取前面所存储的姓名、年龄和是否已婚，如果没有找到相应的值，
             * 就会使用方法中传入的默认值来代替，最后通过Log将这些值打印出来。
             */
            val prefs = getSharedPreferences("data", Context.MODE_PRIVATE)
            val name = prefs.getString("name", "")
            val age = prefs.getInt("age", 0)
            val married = prefs.getBoolean("married", false)
            Log.d("MainActivity", "name is $name")
            Log.d("MainActivity", "age is $age")
            Log.d("MainActivity", "married is $married")
        }
    }
}
```

重启程序，并点击界面上的“Restore data”按钮，可以看到Logcat中已经打印了之前存储的数据。通过这个例子，我们就把SharedPreferences存储的
知识学习完了。相比之下，SharedPreferences存储确实要比文本存储简单方便了许多，应用场景也多了不少，比如很多应用程序中的偏好设置功能其实就使用到了SharedPreferences技术。





### 实现记住密码功能

新建RememberPassword项目，创建activity_login.xml并修改代码：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Account:" />

        <EditText
            android:id="@+id/accountEdit"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical" />
    </LinearLayout>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Password:" />

        <EditText
            android:id="@+id/passwordEdit"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical"
            android:inputType="textPassword" />
    </LinearLayout>

    <!--这里使用了一个新控件：CheckBox。这是一个复选框控件，用户可以通过点击的方式进行选中
        和取消，我们就使用这个控件来表示用户是否需要记住密码。-->
    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <CheckBox
            android:id="@+id/rememberPass"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="18sp"
            android:text="Remember password" />
    </LinearLayout>

    <Button
        android:id="@+id/login"
        android:layout_width="200dp"
        android:layout_height="60dp"
        android:layout_gravity="center_horizontal"
        android:text="Login" />

</LinearLayout>
```

这里使用了一个新控件：CheckBox。这是一个复选框控件，用户可以通过点击的方式进行选中和取消，我们就使用这个控件来表示用户是否需要记住密码。



然后修改LoginActivity中的代码，如下所示：

```kotlin
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.widget.Button
import android.widget.CheckBox
import android.widget.EditText
import android.widget.Toast

class LoginActivity : BaseActivity(){

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)
        // 获取了SharedPreferences对象，然后调用它的getBoolean()方法去获取remember_password这个键对应的值。
        val prefs = getPreferences(Context.MODE_PRIVATE)
        val isRemember = prefs.getBoolean("remember_password", false)
        val accountEdit : EditText = findViewById(R.id.accountEdit)
        val passwordEdit : EditText = findViewById(R.id.passwordEdit)
        val rememberPass : CheckBox = findViewById(R.id.rememberPass)
        val login : Button = findViewById(R.id.login)
        // 如果设置了记住密码，将用户名密码设置到对应的文本框中,第一次登陆时肯定是false
        if (isRemember) {
            // 将账号和密码都设置到文本框中
            val account = prefs.getString("account", "")
            val password = prefs.getString("password", "")
            accountEdit.setText(account)
            passwordEdit.setText(password)
            rememberPass.isChecked = true
        }
        login.setOnClickListener {
            val account = accountEdit.text.toString()
            val password = passwordEdit.text.toString()
            // 如果账号是admin且密码是123456，就认为登录成功
            if (account == "admin" && password == "123456") {
                /**
                 * 在登录成功之后，会调用CheckBox的isChecked()方法来检查复选框是否被选中。如果被选中了，则表示用户想要记
                 * 住密码，这时将remember_password设置为true，然后把account和password对应的值都
                 * 存入SharedPreferences文件中并提交；如果没有被选中，就简单地调用一下clear()方法，
                 * 将SharedPreferences文件中的数据全部清除掉。
                 */
                val editor = prefs.edit()
                if (rememberPass.isChecked) { // 检查复选框是否被选中
                    editor.putBoolean("remember_password", true)
                    editor.putString("account", account)
                    editor.putString("password", password)
                } else {
                    editor.clear()
                }
                editor.apply()
                val intent = Intent(this, MainActivity::class.java)
                startActivity(intent)
                finish()
            } else {
                Toast.makeText(this, "account or password is invalid",
                    Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

可以看到，这里首先在onCreate()方法中获取了SharedPreferences对象，然后调用它的getBoolean()方法去获取remember_password这个键对应的值。一开始当然不存在对应的值了，所以会使用默认值false，这样就什么都不会发生。接着在登录成功之后，会调用CheckBox的isChecked()方法来检查复选框是否被选中。如果被选中了，则表示用户想要记住密码，这时将remember_password设置为true，然后把account和password对应的值都存入SharedPreferences文件中并提交；如果没有被选中，就简单地调用一下clear()方法，将SharedPreferences文件中的数据全部清除掉。



当用户选中了记住密码复选框，并成功登录一次之后，remember_password键对应的值就是true了，这个时候如果重新启动登录界面，就会从SharedPreferences文件中将保存的账号和密码都读取出来，并填充到文本输入框中，然后把记住密码复选框选中，这样就完成记住密码的功能了。



现在重新运行一下程序，可以看到界面上多了一个记住密码复选框，然后账号输入admin，密码输入123456，并选中记住密码复选框，点击登录，就会跳转到
MainActivity。接着在MainActivity中发出一条强制下线广播，会让程序重新回到登录界面，此时会发现，账号和密码已经自动填充到界面上了。



## SQLite数据库存储

Android系统竟然是内置了数据库的！SQLite是一款轻量级的关系型数据库，它的运算速度非常快，占用资源很少，通常只需要几百KB的内存就足够了，因而特别适合在移动设备上使用。SQLite不仅支持标准的SQL语法，还遵循了数据库的ACID事务，所以只要以前使用过其他的关系型数据库，就可以很快地上手SQLite。而SQLite又比一般的数据库要简单得多，它甚至不用设置用户名和密码就可以使用。Android正是把这个功能极为强大的数据库嵌入到了系统当中，使得本地持久化的功能有了一次质的飞跃。



前面我们所学的文件存储和SharedPreferences存储毕竟只适用于保存一些简单的数据和键值对，当需要存储大量复杂的关系型数据的时候，就会发现以上两种存储方式很难应付得了。比如手机的短信程序中可能会有很多个会话，每个会话中又包含了很多条信息内容，并且大部分会话还可能各自对应了通讯录中的某个联系人。很难想象如何用文件或者SharedPreferences来存储这些数据量大、结构性复杂的数据吧？但是使用数据库就可以做得到。



### 创建数据库

Android为了让我们能够更加方便地管理数据库，专门提供了一个SQLiteOpenHelper帮助类，借助这个类可以非常简单地对数据库进行创建和升级。既然有好东西可以直接使用，那我们自然要尝试一下了，下面就对SQLiteOpenHelper的基本用法进行介绍。



首先，要知道SQLiteOpenHelper是一个抽象类，这意味着如果我们想要使用它，就需要创建一个自己的帮助类去继承它。SQLiteOpenHelper中有两个抽象方法：onCreate()和onUpgrade()。我们必须在自己的帮助类里重写这两个方法，然后分别在这两个方法中实现创建和升级数据库的逻辑。



SQLiteOpenHelper中还有两个非常重要的实例方法：getReadableDatabase()和getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则要创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入的时候（如磁盘空间已满），getReadableDatabase()方法返回的对象将以只读的方式打开数据库，而getWritableDatabase()方法则将出现异常。



SQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可。这个构造方法中接收4个参数：第一个参数是Context，这个没什么好说的，必须有它才能对数据库进行操作；第二个参数是数据库名，创建数据库时使用的就是这里指定的名称；第三个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般传入null即可；第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。构建出SQLiteOpenHelper的实例之后，再调用它的getReadableDatabase()或getWritableDatabase()方法就能够创建数据库了，数据库文件会存放在`/data/data/<package name>/databases/`目录下。此时，重写的onCreate()方法也会得到执行，所以通常会在这里处理一些创建表的逻辑。



接下来还是让我们通过具体的例子来更加直观地体会SQLiteOpenHelper的用法吧，首先新建一个DatabaseTest项目。



这里我们希望创建一个名为BookStore.db的数据库，然后在这个数据库中新建一张Book表，表中有id（主键）、作者、价格、页数和书名等列。创建数据库表当然还是需要用建表语句的，这Book表的建表语句如下所示：

```sql
create table Book (
    id integer primary key autoincrement,
    author text,
    price real,
    pages integer,
    name text)
```

SQLite不像其他的数据库拥有众多繁杂的数据类型，它的数据类型很简单：integer表示整型，real表示浮点型，text表示文本类型，blob表示二进制类型。另外，在上述建表语句中，我们还使用了primary key将id列设为主键，并用autoincrement关键字表示id列是自增长的。



然后需要在代码中执行这条SQL语句，才能完成创建表的操作。新建MyDatabaseHelper类继承自SQLiteOpenHelper，代码如下所示：

```kotlin
import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import android.widget.Toast

class MyDatabaseHelper(val context: Context, name:String, version:Int):
    SQLiteOpenHelper(context,name,null,version){

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text)"

    
    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    }
}
```

可以看到，我们把建表语句定义成了一个字符串变量，然后在onCreate()方法中又调用了SQLiteDatabase的execSQL()方法去执行这条建表语句，并弹出一个Toast提示创建成功，这样就可以保证在数据库创建完成的同时还能成功创建Book表。



现在修改activity_main.xml中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >

    
    <Button
        android:id="@+id/createDatabase"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Create Database"
        />


</LinearLayout>
```

布局文件很简单，就是加入了一个按钮，用于创建数据库。最后修改MainActivity中的代码，如下所示：

```kotlin
import android.os.Bundle
import android.widget.Button
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {

    /**
     * 这里我们在onCreate()方法中构建了一个MyDatabaseHelper对象，并且通过构造函数的参
     * 数将数据库名指定为BookStore.db，版本号指定为1，然后在“Create Database”按钮的点击
     * 事件里调用了getWritableDatabase()方法。这样当第一次点击“Create Database”按钮
     * 时，就会检测到当前程序中并没有BookStore.db这个数据库，于是会创建该数据库并调用
     * MyDatabaseHelper中的onCreate()方法，这样Book表也就创建好了，然后会弹出一个
     * Toast提示创建成功。再次点击“Create Database”按钮时，会发现此时已经存在
     * BookStore.db数据库了，因此不会再创建一次。
     */
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // 调用自定义的SQLiteHelper执行创建数据库表的功能
        val dbHelper = MyDatabaseHelper(this, "BookStore.db", 1)
        val createDatabase : Button = findViewById(R.id.createDatabase)
        createDatabase.setOnClickListener {
            dbHelper.writableDatabase
        }
    }
}
```

现在就可以运行一下代码了，在程序主界面点击“Create Database”按钮。此时BookStore.db数据库和Book表应该已经创建成功了，因为当再次点击“Create
Database”按钮时，不会再有Toast弹出。可是又回到了之前的那个老问题：怎样才能证实它们的确创建成功了？



这里我们仍然还是可以使用Device File Explorer，但是这个工具最多只能看到databases目录下出现了一个BookStore.db文件，是无法查看Book表的。因此我们还需要借助一个叫作Database Navigator的插件工具。



安装好Database Navigator后，打开Device File Explorer，然后进入/data/data/<package name>/databases/目录下，可以看到已经存在了一个BookStore.db文件。这个目录下还存在另外一个BookStore.db-journal文件，这是一个为了让数据库能够支持事务而产生的临时日志文件，通常情况下这个文件的大小是0字节，我们可以暂时不用管它。



现在对着BookStore.db文件右击→Save As，将它从模拟器导出到你的计算机的任意位置。然后观察Android Studio的左侧边栏，现在应该多出了一个DB Browser工具，这就是我们刚刚安装的插件了。如果你的左侧边栏中找不到这个工具，也可以使用快捷键Ctrl + Shift +A（Mac系统是command + shift + A）打开搜索功能，在搜索框中输入“DB Browser”即可找到这个工具。



为了打开刚刚导出的数据库文件，我们需要点击这个工具左上角的加号按钮，并选择SQLite选项，然后在弹出窗口的Database配置中选择我们刚才导出的BookStore.db文件，点击“OK”完成配置，这个时候DB Browser中就会显示出BookStore.db数据库里所有的内容了，可以看到，BookStore.db数据库中确实存在了一张Book表，并且Book表中的列也和我们前面使用的建表语句完全匹配，由此证明BookStore.db数据库和Book表确实已经创建成功了。





### 升级数据库

如果足够细心，一定会发现MyDatabaseHelper中还有一个空方法呢！没错，onUpgrade()方法是用于对数据库进行升级的，它在整个数据库的管理工作当中起着非常重要的作用，可千万不能忽视它哟。



目前，DatabaseTest项目中已经有一张Book表用于存放书的各种详细数据，如果我们想再添加一张Category表用于记录图书的分类，该怎么做呢？



比如Category表中有id（主键）、分类名和分类代码这几个列，那么建表语句就可以写成：

```sqlite
create table Category (
    id integer primary key autoincrement,
    category_name text,
    category_code integer)
```

接下来我们将这条建表语句添加到MyDatabaseHelper中，代码如下所示：

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int):
	SQLiteOpenHelper(context, name, null, version) {

	...
	
    private val createCategory = "create table Category (" +
        "id integer primary key autoincrement," +
        "category_name text," +
        "category_code integer)"
    
    
    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        db.execSQL(createCategory)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }
    
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    }
}
```

看上去好像都挺对的吧？现在重新运行一下程序，并点击“Create Database”按钮，咦？竟然没有弹出创建成功的提示。当然，也可以通过DB Browser工具到数据库中再去检查一下，这样你会更加确认Category表没有创建成功！



其实没有创建成功的原因不难思考，因为此时BookStore.db数据库已经存在了，之后不管我们怎样点击“Create Database”按钮，MyDatabaseHelper中的onCreate()方法都不会再次执行，因此新添加的表也就无法得到创建了。



解决这个问题的办法也相当简单，只需要先将程序卸载，然后重新运行，这时BookStore.db数据库已经不存在了，如果再点击“Create Database”按钮，MyDatabaseHelper中的onCreate()方法就会执行，这时Category表就可以创建成功了。



不过，通过卸载程序的方式来新增一张表毫无疑问是很极端的做法，其实我们只需要巧妙地运用SQLiteOpenHelper的升级功能，就可以很轻松地解决这个问题。修改MyDatabaseHelper中的代码，如下所示：

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int):
SQLiteOpenHelper(context, name, null, version) {

    ...
    
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        db.execSQL("drop table if exists Book")
        db.execSQL("drop table if exists Category")
        onCreate(db)
    }
    
}
```

可以看到，我们在onUpgrade()方法中执行了两条DROP语句，如果发现数据库中已经存在Book表或Category表，就将这两张表删除，然后调用onCreate()方法重新创建。这里先将已经存在的表删除，是因为如果在创建表时发现这张表已经存在了，就会直接报错。



接下来的问题就是如何让onUpgrade()方法能够执行了。还记得SQLiteOpenHelper的构造方法里接收的第四个参数吗？它表示当前数据库的版本号，之前我们传入的是1，现在只要传入一个比1大的数，就可以让onUpgrade()方法得到执行了。修改MainActivity中的代码，如下所示：

```kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val dbHelper = MyDatabaseHelper(this, "BookStore.db", 2)
        createDatabase.setOnClickListener {
        	dbHelper.writableDatabase
        }
    }
}
```

这里将数据库版本号指定为2，表示我们对数据库进行升级了。现在重新运行程序，并点击“Create Database”按钮，这时就会再次弹出创建成功的提示。



