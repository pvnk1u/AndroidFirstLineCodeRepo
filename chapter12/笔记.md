# 最佳的UI体验，Material Design实战

其实长久以来，大多数人可能会认为Android系统的UI并不算美观，至少没有iOS系统的美观。以至于很多IT公司在进行应用界面设计的时候，为了保证双平台的统一性，强制要求Android端的界面风格必须和iOS端一致。这种情况在现实工作当中实在是太常见了，这不一定合理。因为对于一般用户来说，他们不太可能会在两个操作系统上分别使用同一个应用，但是必定会在同一个操作系统上使用不同的应用。因此，同一个操作系统中各个应用之间的界面统一性要远比一个应用在双平台的界面统一性重要得多。



但是Android标准的界面设计风格并不是特别被大众所接受，很多公司觉得自己可以设计出更加好看的界面，从而导致Android平台的界面风格长期难以得到统一。为了解决这个问题，Google也是使出了杀手锏，在2014年Google I/O大会上重磅推出了一套全新的界面设计语言——Material Design。



## 什么是Material Design

Material Design是由Google的设计工程师们基于传统优秀的设计原则，结合丰富的创意和科学技术所开发的一套全新的界面设计语言，包含了视觉、运动、互动效果等特性。那么Google凭什么认为Material Design就能解决Android平台界面风格不统一的问题呢？一言以蔽之，好看！



不过，在重磅推出之后，Material Design的普及程度却不是特别理想。因为这只是一个推荐的设计规范，主要是面向UI设计人员的，而不是面向开发者的。很多开发者可能根本就搞不清楚什么样的界面和效果才叫Material Design，就算搞清楚了，实现起来也会很费劲，因为不少Material Design的效果是很难实现的，而Android中几乎没有提供相应的API支持，基本需要靠开发者自己从零写起。



Google当然意识到了这个问题，于是在2015年的Google I/O大会上推出了一个DesignSupport库，这个库将Material Design中最具代表性的一些控件和效果进行了封装，使得开发者即使在不了解Material Design的情况下，也能非常轻松地将自己的应用Material化。后来Design Support库又改名成了Material库，用于给Google全平台类的产品提供MaterialDesign的支持。本章我们就将对Material库进行深入的学习，并且配合AndroidX库中的一些控件来完成一个优秀的Material Design应用。





新建一个MaterialTest项目。



## Toolbar

Toolbar将会是我们本章接触的第一个控件，是由AndroidX库提供的。对于Toolbar暂时应该还是比较陌生的，但是对于它的另一个相关控件ActionBar就应该有点熟悉了。每个Activity最顶部的那个标题栏其实就是ActionBar，之前我们编写的所有程序里一直都有它的身影。



不过ActionBar由于其设计的原因，被限定只能位于Activity的顶部，从而不能实现一些Material Design的效果，因此官方现在已经不再建议使用ActionBar了。



Toolbar的强大之处在于，它不仅继承了ActionBar的所有功能，而且灵活性很高，可以配合其他控件完成一些Material Design的效果，下面就来具体学习一下。



首先要知道，任何一个新建的项目，默认都是会显示ActionBar的，这个已经见识过太多次了。那么这个ActionBar到底是从哪里来的呢？其实这是根据项目中指定的主题来显示的。打开AndroidManifest.xml文件看一下，如下所示：

```xml
<application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MaterialTest"
        tools:targetApi="31" />
```

可以看到，这里使用android:theme属性指定了一个AppTheme的主题。那么这个AppTheme又是在哪里定义的呢？打开res/values/themes.xml文件，代码如下所示：

```xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.MaterialTest" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_500</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/white</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_700</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>
</resources>
```

这里定义了一个叫AppTheme的主题，然后指定它的parent主题是Theme.AppCompat.Light. DarkActionBar。这个DarkActionBar是一个深色的ActionBar主题，之前所有的项目中自带的ActionBar就是因为指定了这个主题才出现的。



而现在我们准备使用Toolbar来替代ActionBar，因此需要指定一个不带ActionBar的主题，通常有Theme.AppCompat.NoActionBar 和Theme.AppCompat.Light.NoActionBar这两种主题可选。其中Theme.AppCompat.NoActionBar表示深色主题，它会将界面的主体颜色设成深色，陪衬颜色设成浅色。而Theme.AppCompat.Light.NoActionBar表示浅色主题，它会将界面的主体颜色设成浅色，陪衬颜色设成深色。具体的效果可以自己动手试一试，这里由于我们之前的程序一直都是以浅色为主的，那么就选用浅色主题了，如下所示：









