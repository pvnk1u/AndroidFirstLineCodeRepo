# 全局大喇叭：广播机制

上学的时候，每个班级的教室里都装有一个喇叭，这些喇叭接到学校的广播室，一旦有什么重要的通知，就会播放一条广播来告知全校的师生。类似的工作机制其实在计算机领域也有很广泛的应用，如果了解网络通信原理应该会知道，在一个IP网络范围中，最大的IP地址是被保留作为广播地址来使用的。比如某个网络的IP范围是192.168.0.XXX，子网掩码是255.255.255.0，那么这个网络的广播地址就是192.168.0.255。广播数据包会被发送到同一网络上的所有端口，这样该网络中的每台主机都会收到这条广播。



为了便于进行系统级别的消息通知，Android也引入了一套类似的广播消息机制。但Android中的广播机制显得更加灵活。



## 广播机制简介

为什么说Android中的广播机制更加灵活呢？这是因为Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会收到自己所关心的广播内容，这些广播可能是来自于系统的，也可能是来自于其他应用程序的。Android提供了一套完整的API，允许应用程序自由地发送和接收广播。发送广播的方法其实之前稍微提到过，就是学过的Intent。而接收广播的方法则需要引入一个新的概念——BroadcastReceiver。



BroadcastReceiver的具体用法将会在下一节介绍，这里先来了解一下广播的类型。**Android中的广播主要可以分为两种类型：标准广播和有序广播。**

1. 标准广播（normal broadcasts）

   **是一种完全异步执行的广播，在广播发出之后，所有的BroadcastReceiver几乎会在同一时刻收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。**

2. 有序广播（orderd broadcasts）

   **是一种同步执行的广播，在广播发出之后，同一时刻只会有一个BroadcastReceiver能够收到这条广播消息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。所以此时的BroadcastReceiver是有先后顺序的，优先级高的BroadcastReceiver就可以先收到广播消息，并且前面的BroadcastReceiver还可以截断正在传递的广播，这样后面的BroadcastReceiver就无法收到广播消息了。**



## 接收系统广播

Android内置了很多系统级别的广播，可以在应用程序中通过监听这些广播来得到各种系统的状态信息。比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播，系统时间发生改变也会发出一条广播，等等。如果想要接收这些广播，就需要使用BroadcastReceiver，下面就来看一下它的具体用法。





### 动态注册监听时间变化

可以根据自己感兴趣的广播，自由地注册BroadcastReceiver，这样当有相应的广播发出时，相应的BroadcastReceiver就能够收到该广播，并可以在内部进行逻辑处理。注册BroadcastReceiver的方式一般有两种：在代码中注册和在AndroidManifest.xml中注册。其中前者也被称为动态注册，后者也被称为静态注册。



那么如何创建一个BroadcastReceiver呢？其实只需新建一个类，让它继承自BroadcastReceiver，并重写父类的onReceive()方法就行了。这样当有广播到来时，onReceive()方法就会得到执行，具体的逻辑就可以在这个方法中处理。



新建一个BroadcastTest项目，然后修改MainActivity中的代码，如下所示：

```kotlin
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {

    lateinit var timeChangeReceiver : TimeChangeReceiver

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 创建了一个IntentFilter的实例，并给它添加了一个值为android.intent.action.TIME_TICK的action
         * 当系统时间发生变化时，系统发出的正是一条值为android.intent.action.TIME_TICK的广播，
         * 也就是说我们的BroadcastReceiver想要监听什么广播，就在这里添加相应的action。
         */
        val intentFilter = IntentFilter()
        intentFilter.addAction("android.intent.action.TIME_TICK")
        /**
         * 创建了一个TimeChangeReceiver的实例，然后调用registerReceiver()方法进行注册，
         * 将TimeChangeReceiver的实例和IntentFilter的实例都传了进去，这样
         * TimeChangeReceiver就会收到所有值为android.intent.action.TIME_TICK的广播，
         * 也就实现了监听系统时间变化的功能。
         */
        timeChangeReceiver = TimeChangeReceiver()
        registerReceiver(timeChangeReceiver,intentFilter)
    }

    /**
     * 要记得，动态注册的BroadcastReceiver一定要取消注册才行，这里是在
     * onDestroy()方法中通过调用unregisterReceiver()方法来实现的。
     */
    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(timeChangeReceiver)
    }


    /**
     * 内部类TimeChangeReceiver，这个类是继承自BroadcastReceiver的，
     * 并重写了父类的onReceive()方法。这样每当系统时间发生变化时，
     * onReceive()方法就会得到执行，这里只是简单地使用Toast提示了一段文本信息
     */
    inner class TimeChangeReceiver : BroadcastReceiver(){

        override fun onReceive(context: Context?, intent: Intent?) {
            Toast.makeText(context,"Time has changed",Toast.LENGTH_SHORT).show()
        }
    }
}
```

可以看到，我们在MainActivity中定义了一个内部类TimeChangeReceiver，这个类是继承自BroadcastReceiver的，并重写了父类的onReceive()方法。这样每当系统时间发生变化时，onReceive()方法就会得到执行，这里只是简单地使用Toast提示了一段文本信息。



然后观察onCreate()方法，首先我们创建了一个IntentFilter的实例，并给它添加了一个值为android.intent.action.TIME_TICK的action，为什么要添加这个值呢？因为当系统时间发生变化时，系统发出的正是一条值为android.intent.action.TIME_TICK的广播，也就是说我们的BroadcastReceiver想要监听什么广播，就在这里添加相应的action。接下来创建了一个TimeChangeReceiver的实例，然后调用registerReceiver()方法进行注册，将TimeChangeReceiver的实例和IntentFilter的实例都传了进去，这样TimeChangeReceiver就会收到所有值为android.intent.action.TIME_TICK的广播，也就实现了监听系统时间变化的功能。



最后要记得，动态注册的BroadcastReceiver一定要取消注册才行，这里我们是在onDestroy()方法中通过调用unregisterReceiver()方法来实现的。



整体来说，代码还是非常简单的。现在运行一下程序，然后静静等待时间发生变化。系统每隔一分钟就会发出一条android.intent.action.TIME_TICK的广播，因此我们最多只需要等待一分钟就可以收到这条广播了。



这就是动态注册BroadcastReceiver的基本用法，虽然这里我们只使用了一种系统广播来举例，但是接收其他系统广播的用法是一模一样的。Android系统还会在亮屏熄屏、电量变化、网络变化等场景下发出广播。如果想查看完整的系统广播列表，可以到如下的路径中去查看：

```
<Android SDK>/platforms/<任意android api版本>/data/broadcast_actions.txt
```





