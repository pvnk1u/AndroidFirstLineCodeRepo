# 后台默默的劳动者，探究Service



## Service是什么

Service是Android中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而且还要求长期运行的任务。Service的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，Service仍然能够保持正常运行。



不过需要注意的是，Service并不是运行在一个独立的进程当中的，而是依赖于创建Service时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的Service也会停止运行。



**另外，也不要被Service的后台概念所迷惑，实际上Service并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在Service的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。**那么本章的第一堂课，就先来学习一下关于Android多线程编程的知识。



## Android多线程编程

当我们需要执行一些耗时操作，比如发起一条网络请求时，考虑到网速等其他原因，服务器未必能够立刻响应我们的请求，如果不将这类操作放在子线程里运行，就会导致主线程被阻塞，从而影响用户对软件的正常使用。下面就让我们从线程的基本用法开始学起吧。



### 线程的基本用法

Android多线程编程其实并不比Java多线程编程特殊，基本是使用相同的语法。比如，定义一个线程只需要新建一个类继承自Thread，然后重写父类的run()方法，并在里面编写耗时逻辑即可，如下所示：

```kotlin
class MyThread : Thread() {
    override fun run() {
    	// 编写具体的逻辑
    }
}
```

那么该如何启动这个线程呢？其实很简单，只需要创建MyThread的实例，然后调用它的start()方法即可，这样run()方法中的代码就会在子线程当中运行了，如下所示：

```kotlin
MyThread().start()
```

当然，使用继承的方式耦合性有点高，我们会更多地选择使用实现Runnable接口的方式来定义一个线程，如下所示：

```kotlin
class MyThread : Runnable {
    override fun run() {
    	// 编写具体的逻辑
    }
}
```

如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示：

```kotlin
val myThread = MyThread()
Thread(myThread).start()
```

可以看到，Thread的构造函数接收一个Runnable参数，而我们创建的MyThread实例正是一个实现了Runnable接口的对象，所以可以直接将它传入Thread的构造函数里。接着调用Thread的start()方法，run()方法中的代码就会在子线程当中运行了。



当然，如果不想专门再定义一个类去实现Runnable接口，也可以使用Lambda的方式，这种写法更为常见，如下所示：

```kotlin
Thread {
	// 编写具体的逻辑
}.start()
```

以上几种线程的使用方式应该不会感到陌生，因为在Java中创建和启动线程也是使用同样的方式。而Kotlin还给我们提供了一种更加简单的开启线程的方式，写法如下：

```kotlin
thread {
	// 编写具体的逻辑
}
```

**这里的thread是一个Kotlin内置的顶层函数，我们只需要在Lambda表达式中编写具体的逻辑就可以了，连start()方法都不用调用，thread函数在内部帮我们全部都处理好了。**



了解了线程的基本用法后，下面我们来看一下Android多线程编程与Java多线程编程不同的地方。



### 在子线程中更新UI

和许多其他的GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，必须在主线程中进行，否则就会出现异常。



眼见为实，通过一个具体的例子来验证一下吧。新建一个AndroidThreadTest项目，然后修改activity_main.xml中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/changeTextBtn"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Change Text" />
    
    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Hello world"
        android:textSize="20sp" />
</RelativeLayout>
```



布局文件中定义了两个控件：TextView用于在屏幕的正中央显示一个"Hello world"字符串；Button用于改变TextView中显示的内容，我们希望在点击“Button”后可以把TextView中显示的字符串改成"Nice to meet you"。



接下来修改MainActivity中的代码，如下所示：

```kotlin
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import kotlin.concurrent.thread

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val changeTextBtn:Button = findViewById(R.id.changeTextBtn)
        val textView : TextView = findViewById(R.id.textView)
        changeTextBtn.setOnClickListener{
            thread {
                textView.text = "Nice to meet you"
            }
        }
    }
}
```

可以看到，我们在“Change Text”按钮的点击事件里面开启了一个子线程，然后在子线程中调用TextView的setText()方法将显示的字符串改成"Nice to meet you"。代码的逻辑非常简单，只不过我们是在子线程中更新UI的。现在运行一下程序，并点击“Change Text”按钮，会发现程序果然崩溃了。观察Logcat中的错误日志，可以看出是由于在子线程中更新UI所导致的。



**由此证实了Android确实是不允许在子线程中进行UI操作的。但是有些时候，我们必须在子线程里执行一些耗时任务，然后根据任务的执行结果来更新相应的UI控件，这该如何是好呢？**



**对于这种情况，Android提供了一套异步消息处理机制，完美地解决了在子线程中进行UI操作的问题。我们将在下一小节中再去分析它的原理。**



修改MainActivity中的代码，如下所示：

```kotlin
package io.github.pvnk1u

import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import kotlin.concurrent.thread

class MainActivity : AppCompatActivity() {



    // 定义了一个整型变量updateText，用于表示更新TextView这个动作
    val updateText = 1


    /**
     * 新增一个Handler对象，并重写父类的handleMessage()方法，在这里对具体的Message进行处理。
     * 如果发现Message的what字段的值等于updateText，就将TextView显示的内容改成“Nice to meet you”。
     */
    val handler = object : Handler(Looper.getMainLooper()) {
        override fun handleMessage(msg: Message) {
            // 在这里可以进行UI操作
            val textView : TextView = findViewById(R.id.textView)
            when (msg.what) {
                updateText -> textView.text = "Nice to meet you"
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        /**
         * 没有在子线程里直接进行UI操作，而是创建了一个Message（android.os.Message）对象，并将它的
         * what字段的值指定为updateText，然后调用Handler的sendMessage()方法将这条
         * Message发送出去。很快，Handler就会收到这条Message，并在handleMessage()方法中
         * 对它进行处理。注意此时handleMessage()方法中的代码就是在主线程当中运行的了，所以
         * 我们可以放心地在这里进行UI操作。接下来对Message携带的what字段的值进行判断，如果等
         * 于updateText，就将TextView显示的内容改成“Nice to meet you”。
         */
        val changeTextBtn:Button = findViewById(R.id.changeTextBtn)
        changeTextBtn.setOnClickListener {
            thread {
                val msg = Message()
                msg.what = updateText
                handler.sendMessage(msg) // 将Message对象发送出去
            }
        }
    }




}
```

这里我们先是定义了一个整型变量updateText，用于表示更新TextView这个动作。然后新增一个Handler对象，并重写父类的handleMessage()方法，在这里对具体的Message进行处理。如果发现Message的what字段的值等于updateText，就将TextView显示的内容改成“Nice to meet you”。



下面再来看一下“Change Text”按钮的点击事件中的代码。可以看到，这次我们并没有在子线程里直接进行UI操作，而是创建了一个Message（android.os.Message）对象，并将它的what字段的值指定为updateText，然后调用Handler的sendMessage()方法将这条Message发送出去。很快，Handler就会收到这条Message，并在handleMessage()方法中对它进行处理。注意此时handleMessage()方法中的代码就是在主线程当中运行的了，所以我们可以放心地在这里进行UI操作。接下来对Message携带的what字段的值进行判断，如果等于updateText，就将TextView显示的内容改成“Nice to meet you”。



现在重新运行程序，可以看到屏幕的正中央显示着“Hello world”。然后点击一下“ChangeText”按钮，显示的内容就被替换成“Nice to meet you”。



这样就已经掌握了Android异步消息处理的基本用法，使用这种机制就可以出色地解决在子线程中更新UI的问题。不过恐怕对它的工作原理还不是很清楚，下面我们就来分析一下Android异步消息处理机制到底是如何工作的。



